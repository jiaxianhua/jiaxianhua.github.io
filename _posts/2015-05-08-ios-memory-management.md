---
layout: post
title: "iOS 内存管理" 
description: ""
category: iOS
tags: [iOS, arc]
---
{% include JB/setup %}

软件运行时会分配和使用设备的内存资源，因此，在软件开发的过程中，需要进行内存管理，以保证高效、快速的分配内存，并且在适当的时候释放和回收内存资源。

## 一、Objective-C内存管理的对象
---

IOS开发中，内存中的对象主要有两类，一类是值类型，比如int、float、struct等基本数据类型，另一类是引用类型，也就是继承自NSObject类的所有的OC对象。前一种值类型不需要我们管理，后一种引用类型是需要我们管理内存的，一旦管理不好，就会产生非常糟糕的后果。

### 为什么值类型不需要管理，而引用类型需要管理呢？那是因为他们分配内存方式不一样。

值类型会被放入栈中，他们依次紧密排列，在内存中占有一块连续的内存空间，遵循先进后出的原则。引用类型会被放到堆中，当给对象分配内存空间时，会随机的从内存当中开辟空间，对象与对象之间可能会留有不确定大小的空白空间，因此会产生很多内存碎片，需要我们管理。

栈内存与堆内存从性能上比较，栈内存要优于堆内存，这是因为栈遵循先进后出的原则，因此当数据量过大时，存入栈会明显的降低性能。因此，我们会把大量的数据存入堆中，然后栈中存放堆的地址，当需要调用数据时，就可以快速的通过栈内的地址找到堆中的数据。

值类型和引用类型之间是可以相互转化的，把值类型转化为引用类型的过程叫做装箱，比如把int包装为NSNumber，这个过程会增加程序的运行时间，降低性能。而把引用类型转为值类型的过程叫做拆箱，比如把NSNumer转为float，在拆箱的过程中，我们一定要注意数据原有的类型，如果类型错误，可能导致拆箱失败，因此会存在安全性的问题。手动的拆箱和装箱，都会增加程序的运行时间，降低代码可读性，影响性能。

在IOS开发过程中，栈内存中的值类型系统会自动管理，堆内存中的引用类型是需要我们管理的。每个OC对象内部都专门有四个字节来存储引用计数器，它是一个整数，表示对象被引用的次数，通过它可以判断对象是否被回收，如果引用计数为0，对象回收，不为0不回收。当对象执行alloc、new或者retain时，引用计数加1，release时，引用计数减1。

## 二、Objective-C管理内存的方式
---

Objective-c中提供了两种内存管理机制MRC（Mannul Reference Counting）和ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。MRC与ARC区别如下图所示。

![memory-1](/assets/img/ios/memory-1.png)

* MRC（人工引用计数），手动管理内存。

MRC模式下，所有的对象都需要手动的添加retain、release代码来管理内存。使用MRC，需要遵守谁创建，谁回收的原则。也就是谁alloc，谁release；谁retain，谁release。

当引用计数为0的时候，必须回收，引用计数不为0，不能回收，如果引用计数为0，但是没有回收，会造成内存泄露。如果引用计数为0，继续释放，会造成野指针。为了避免出现野指针，我们在释放的时候，会先让指针=nil。

* ARC(自动引用计数)，自动管理内存。

ARC是IOS5推出的新功能，通过ARC，可以自动的管理内存。在ARC模式下，只要没有强指针（强引用）指向对象，对象就会被释放。在ARC模式下，不允许使用retain、release、retainCount等方法。并且，如果使用dealloc方法时，不允许调用[super dealloc]方法。

ARC模式下的property变量修饰词为strong、weak，相当于MRC模式下的retain、assign。strong :代替retain，缺省关键词，代表强引用。weak：代替assign，声明了一个可以自动设置nil的弱引用，但是比assign多一个功能，指针指向的地址被释放之后，指针本身也会自动被释放。

## 三、与内存有关的修饰符
---

**strong** ：强引用，ARC中使用，与MRC中retain类似，使用之后，计数器+1。

**weak** ：弱引用 ，ARC中使用，如果只想的对象被释放了，其指向nil，可以有效的避免野指针，其引用计数为1。

**readwrite** : 可读可写特性，需要生成getter方法和setter方法时使用。

**readonly** : 只读特性，只会生成getter方法 不会生成setter方法，不希望属性在类外改变。

**assign** ：赋值特性，不涉及引用计数，弱引用，setter方法将传入参数赋值给实例变量，仅设置变量时使用。

**retain** ：表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。

**copy** ：表示拷贝特性，setter方法将传入对象复制一份，需要完全一份新的变量时。

**nonatomic** ：非原子操作，不加同步，多线程访问可提高性能，但是线程不安全的。决定编译器生成的setter getter是否是原子操作。

**atomic** ：原子操作，同步的，表示多线程安全，与nonatomic相反。

## 四、MRC与ARC混编
---

MRC与ARC理论上是不能兼容的，也就是你如果创建的项目是ARC模式的，在你的代码中是不能使用release，否则会出现内存问题。现在大部分程序都会选择ARC的方式，但是很多第三方的框架是MRC模式，如果想把这些第三方的文件加到自己项目中，需要进行标识，否则编译的时候会出现错误。

在ARC的项目中，对MRC的文件可以添加编译选项-fno-objc-arc的标识；在MRC的项目中，对ARC的文件可以添加编译选项 -fobjc-arc的标识。 步骤如下图所示。

![memory-2](/assets/img/ios/memory-2.png)

把MRC文件转为ARC，实际上是去掉文件中的retain、release，因此也通过下图中方式完成。

![memory-3](/assets/img/ios/memory-3.png)

> 原文:<http://www.code4blog.com/archives/678>
